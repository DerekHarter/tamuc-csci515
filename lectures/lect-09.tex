% Created 2015-03-31 Tue 20:54
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{minted}
\author{Derek Harter}
\date{CSci 515 Spring 2015 \textit{<2015-03-31 Tue>}}
\title{Lecture 09 Notes}
\hypersetup{
  pdfkeywords={},
  pdfsubject={Lecture 09 Notes.},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.4)}}
\begin{document}

\maketitle

\section{First Session (11 - 11:40)}
\label{sec-1}
\subsection{Introduction to Analysis of Algorithms}
\label{sec-1-1}
Analysis of algorithms is a branch of computer science that studies
the performance of algorithms, especially their run time and space
requirements.  Most classes tend to emphasize the run time complexity,
but space complexity can be just as important, e.g if your program
can't fit into the size of primary memory for a supercomputing
application, if often will go from being feasible to compute, to
impossible.

\begin{itemize}
\item The practical goal if analysis of algorithms is to predict the
perormance of different algorithms, as a function of the input size,
in order to guide design decisions.
\item The goal is to make meaningful comparisons between algorithms, but
some problems:
\begin{itemize}
\item The relative performance might depend on characteristics of hardware.
Alg 1 faster machine A, Alg 2 faster machine B.  Specify a machine model.
\item Relative performance might depend on details of dataset.  Thus usually
look at best, worst and average case behavior.
\item Relative importance depends on the size of the input.  A sorting
algorithm will be slower for a small list than for a very large one.
\end{itemize}
\item Usual solution for last: specify run time (or number of operations)
as a function of problem size.  Compare functions \textbf{asymptotically} 
as the problem size increases.
\end{itemize}
\subsection{Order of Growth}
\label{sec-1-2}
Suppose you have analyzed two algorithms and expressed their run times in
terms of the size of the input: Algorithm A takes $100n + 1$ steps
to solve a problem with size $n$; Algorithm B takes $n^2 + n + 1$ steps.

Which algorithm is "better" in terms of time complexity (number of steps)?

The following table shows run time of algorithms for different problem sizes:

\begin{center}
\begin{tabular}{rrr}
Input & Run time of & Run time of\\
size & Algorithm A & Algorithm B\\
\hline
10 & 1001 & 111\\
100 & 10001 & 10101\\
1000 & 100 001 & 1001001\\
10000 & 1000001 & $> 10^{10}$\\
\end{tabular}
\end{center}

\begin{itemize}
\item Big O notation
\item Time and Space
\item Relative growth as a function of the size $N$ of input.
\end{itemize}
\section{Second Session (11:45 - 12:30)}
\label{sec-2}
\subsection{Sorting Arrays}
\label{sec-2-1}
\begin{itemize}
\item Bubble Sort
\item Insertion Sort
\item Merge Sort
\end{itemize}

\section{Third Session (12:40 - 1:40)}
\label{sec-3}

\begin{center}
\begin{tabular}{llll}
\textbf{Algorithm} & \textbf{Best case} & \textbf{Expected} & \textbf{Worst case}\\
Bubble sort & $O(N^2)$ & $O(N^2)$ & $O(N^2)$\\
Insertion sort & $O(N^2)$ & $O(N^2)$ & $O(N^2)$\\
Merge Sort & $O(N log N)$ & $O(N log N)$ & $O(N log N)$\\
Linear search & $O(1)$ & $O(N)$ & \$O(N)\\
Binary search & $O(1)$ & $O(log N)$ & $O(log N)$\\
\end{tabular}
\end{center}
% Emacs 24.3.1 (Org mode 8.2.4)
\end{document}
